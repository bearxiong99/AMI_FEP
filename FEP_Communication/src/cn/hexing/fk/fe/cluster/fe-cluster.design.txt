前置机集群设计思路：
假设: 终端RTU-i归属于网关GATE(m);
BP(1,2) 集群；FE(1,2)集群
最小同步元素列表：终端对应网关关系; 终端手机号码变更; 终端短信应用号变更;  (可靠同步) 
扩展同步元素列表：终端上行 (报文类型：心跳...; 上行时间; 报文长度; 主动上行标识 )  (广播同步)
RTU-i下行过程分析:
 RTU-i  ->  BP(1)  ->  FE(1)
 FE(1)收到下行请求，通道选择的决策依据：
   (a 终端归属网关的关系; b 终端最后一次GPRS上行时间; c 终端最后一个下行时间; d 终端最后一次应答时间)
 假定终端上次上行在FE(2), 那么依赖于决策依据选择合适通道，直接发送到GPRS网关或者短信网关。
 
 上行过程分析：
 假定：BP(1) BP(2) 连接到 FE(1) FE(2)
上行报文处理规则：
	****>  同一个终端在某个时段上行报文只能在某一个BP内部处理（防止数据库记录重复）。
需要解决的难点:
    （1）多个BP连接到多个FE，如何在FE识别同一个BP？  思路：不同BP来自不同IP；
   （2）终端如何对应BP？  思路：按照地市码分配到每个BP；按照RTUA取模。
方法： (1) 预先配置分配策略，不需要同步分配策略。
	  (2) 同步分配策略，对于BP某个时刻与某个FE断开，同步需要特别考虑。
算法：
	当BP连接成功后，第一次发送心跳(或者叫请求上行报文)到FE，则产生“BP加入”事件（伪事件，只是表达这个意思）；
	当BP断开连接，或者FE两个心跳间隔没有收到BP心跳，则产生“BP退出”事件；
	事件定义：bp.join,  bp.leave
	FE需要同步BP的join leave事件，保障所有FE，维持相同的终端上行规则。由FE同步机制完成。
case 1 ( general join case )
							FE1							FE2
{ bp2.join.fe1 }           { bp1 }					   { bp1 }			
			->			   { bp1, bp2 } 			   { bp1 }				非正常状态
{ bp2.join.fe2 }		   { bp1, bp2 }				   { bp1, bp2 }			正常状态

case 2 ( general leave case )
{ bp1.leave.fe2 } 		   { bp1,bp2 }				   { bp1,bp2 }
			->			   { bp1,bp2 }				   { bp2 }				非正常状态
{ bp1.leave.fe1 }		   { bp2 }					   { bp2 }				正常状态

case 3 ( initialize )
							FE1							FE2
{ bp1.join.fe1 }           {  }					   		{  }			
			->			   { bp1 } 			   			{  }				非正常状态
{ bp1.join.fe2 }		   { bp1 }				   		{  }			
			->			   { bp1 } 			   			{ bp1 }				正常状态

状态变迁时，允许少量终端上行报文分发到不同BP，降低多BP、多FE之间的同步复杂性。
否则需要实现BP的join与leave事件（即同时成功连接到所有FE，才能发送JOIN事件；与任何一个FE断开，都是LEAVE事件）。




